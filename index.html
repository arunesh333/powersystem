<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lab Experiments</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="main-content">

        <div class="lab-column">
            <header>
                <h1>Power System Lab Exps</h1>
            </header>
            
            <main class="experiment-list">
                <a href="#" class="lab-item" data-copy-target="exp1-code">1. Formation of bus admittance matrix using MATLAB program.</a>
                <a href="#" class="lab-item" data-copy-target="exp2-code">2. Formation of bus impedance matrix using bus building algorithm in MATLAB.</a>
                <a href="#" class="lab-item" data-copy-target="exp3-code">3. MATLAB solution for Gauss-Seidel load flow.</a>
                <a href="#" class="lab-item" data-copy-target="exp4-code">4. NR load flow analysis using MATLAB program.</a>
                <a href="#" class="lab-item" data-copy-target="exp5-code">5. MATLAB solution for Fast Decoupled load flow.</a>
                <a href="#" class="lab-item" data-copy-target="exp6-code">6. MATLAB solution of swing equation by point-by-point method.</a>
                <a href="#" class="lab-item" data-copy-target="exp7-code">7. MATLAB program for obtaining critical clearing angle and time using EAC (SMIB system).</a>
            </main>
        </div>

        <div class="lab-column">
            <header>
                <h1>SGEV Lab Exps</h1>
            </header>
            
            <main class="experiment-list">
                <a href="#" class="lab-item unavailable">9. Battery Balancing and parameter estimation for Li-ion batteries</a>
                
                <a href="files/Exp10_thermal_modelling.slx" class="lab-item" download>10. Thermal modelling of Li-ion batteries</a>

                <a href="#" class="lab-item unavailable">11. Development of an enhanced self-correcting model of Li-ion battery and determination of its coulombic efficiency</a>

                <a href="#" class="lab-item unavailable">12. Modelling and analysis of a hybrid electric vehicle drivetrain with modified Indian driving cycle</a>

                <div class="item-grid">
                    <a href="files/Exp13_CCCV.slx" class="lab-item" download>13. Dev. of supervisory control algorithms for BMS - A</a>
                    <a href="files/Exp13_CCCV_simscape.slx" class="lab-item" download>13. Dev. of supervisory control algorithms for BMS - B</a>
                </div>

                <div class="item-grid">
                    <a href="files/Exp14_Kalman_final.slx" class="lab-item" download>14. Analysis of SOC estimation algorithm using the EKF - Simulink</a>
                    <a href="#" class="lab-item" data-copy-target="exp14-code">14. Analysis of SOC estimation algorithm using the EKF - Matlab Code</a>
                </div>

            </main>
        </div>

    </div> <div id="copy-notification">
        Copied to clipboard!
    </div>
    <div id="unavailable-notification">
        Resource not available!
    </div>

<textarea id="exp1-code" class="hidden-code">
    Formation of bus admittance matrix using MATLAB Program.
    Clc; clear;
    % Line data: [From To R X B/2]
    L = [1 2 0.2 0.8 0.02/2;
    2 3 0.3 0.9 0.03/2;
    2 4 0.25 1.0 0.04/2;
    4 3 0.2 0.8 0.02/2;
    1 3 0.1 0.4 0.01/2];
    nl = L(:,1); nr = L(:,2); R = L(:,3); X = L(:,4); Bc = 1i*L(:,5);
    Z = R + 1i*X; y = 1./Z;
    nbus = max(max(nl), max(nr)); nbr = length(L);
    Y = zeros(nbus);
    for k=1:nbr
    Y(nl(k),nr(k)) = Y(nl(k),nr(k)) - y(k);
    Y(nr(k),nl(k)) = Y(nr(k),nl(k)) - y(k);
    end
    for k=1:nbr
    Y(nl(k),nl(k)) = Y(nl(k),nl(k)) + y(k) + Bc(k);
    Y(nr(k),nr(k)) = Y(nr(k),nr(k)) + y(k) + Bc(k);
    end
    disp('Ybus Matrix ='); disp(Y);
</textarea>

<textarea id="exp2-code" class="hidden-code">
    % Formation of Bus Impedance Matrix using Bus Building Algorithm in MATLAB
clc; clear;

% Line data format: [from_bus, to_bus, R, X]
linedata = [
    0 1 0 1.25;
    2 4 0 0.125;
    1 2 0 0.25;
    2 3 0 0.4;
    4 3 0 0.2;
    3 0 0 1.25
];

% Extract columns
nl = linedata(:,1);     % 'From' bus
nr = linedata(:,2);     % 'To' bus
R  = linedata(:,3);     % Resistance
X  = linedata(:,4);     % Reactance

% Initialize variables
nbr  = length(linedata(:,1));             % Number of branches
nbus = max(max(nl), max(nr));             % Number of buses
ZB   = R + 1j * X;                        % Branch impedance
Zbus = zeros(nbus, nbus);                 % Initialize Zbus matrix
tree = 0;                                 % Tree count
ntree = ones(nbr, 1);                     % Branch status tracker

%% Step 1: Add branch from new bus to reference bus
for I = 1:nbr
    if nl(I) == 0 || nr(I) == 0
        if nl(I) == 0
            n = nr(I);
        else
            n = nl(I);
        end

        if abs(Zbus(n,n)) == 0
            Zbus(n,n) = ZB(I);
            tree = tree + 1;
        else
            Zbus(n,n) = (Zbus(n,n) * ZB(I)) / (Zbus(n,n) + ZB(I));
        end

        ntree(I) = 2;
    end
end

%% Step 2: Add branch from new bus to existing bus
while tree < nbus
    for n = 1:nbus
        nadd = 1;
        if abs(Zbus(n,n)) == 0
            for I = 1:nbr
                if nadd == 1
                    if nl(I) == n || nr(I) == n
                        if nl(I) == n
                            k = nr(I);
                        else
                            k = nl(I);
                        end

                        if abs(Zbus(k,k)) ~= 0
                            for m = 1:nbus
                                if m ~= n
                                    Zbus(m,n) = Zbus(m,k);
                                    Zbus(n,m) = Zbus(m,k);
                                end
                            end
                            Zbus(n,n) = Zbus(k,k) + ZB(I);
                            tree = tree + 1;
                            nadd = 2;
                            ntree(I) = 2;
                        end
                    end
                end
            end
        end
    end
end

%% Step 3: Add links between two old buses
for n = 1:nbus
    for I = 1:nbr
        if ntree(I) == 1
            if nl(I) == n || nr(I) == n
                if nl(I) == n
                    k = nr(I);
                else
                    k = nl(I);
                end

                DM = Zbus(n,n) + Zbus(k,k) + ZB(I) - 2 * Zbus(n,k);

                for jj = 1:nbus
                    AP = Zbus(jj,n) - Zbus(jj,k);
                    for kk = 1:nbus
                        AT = Zbus(n,kk) - Zbus(k,kk);
                        DELZ(jj,kk) = AP * AT / DM;
                    end
                end

                Zbus = Zbus - DELZ;
                ntree(I) = 2;
            end
        end
    end
end

%% Final Output
fprintf('\nThe Bus Impedance Matrix for the given network is:\n');
disp(Zbus);
</textarea>

<textarea id="exp3-code" class="hidden-code">
    clc;
clear;
V = [1.05+0j; 1+0j; 1+0j];
Psch = [0; -138.6/100; -256.6/100];
Qsch = [0; -45.2/100; 0];
Z12 = 0.02 + 0.04j;
Z13 = 0.01 + 0.03j;
Z23 = 0.0125 + 0.025j;
Y12 = -1/Z12;
Y13 = -1/Z13;
Y23 = -1/Z23;
Y11 = - (Y12 + Y13);
Y22 = - (Y12 + Y23);
Y33 = - (Y13 + Y23);
Y21 = Y12;
Y31 = Y13;
Y32 = Y23;
Ybus = [Y11, Y12, Y13;
Y21, Y22, Y23;
Y31, Y32, Y33];
for i = 2:3
sumYV = 0;
for j = 1:3
if j ~= i
sumYV = sumYV + Ybus(i,j)*V(j);
end
end
V(i) = (1/Ybus(i,i)) * ((Psch(i) - 1j*Qsch(i))/conj(V(i)) - sumYV);
end
for i = 1:3
mag = abs(V(i));
ang = angle(V(i))*180/pi;
fprintf('Bus %d: %.4f ∠ %.4f°\n', i, mag, ang);
end
</textarea>

<textarea id="exp4-code" class="hidden-code">
    clc
clear
V=[1.0;1.0]; %Voltage magnitude of buses (for PQ bus initialize)
d=[0;0]; %Bus angles in radians
Ps=-1.0; % Scheduled bus Real Power
Qs=-0.5; % Scheduled bus Reactive Power
% Bus admittance matrix of the system
YB=[3-j*4,-3+j*4;-3+j*4 3-j*4];
Y= abs(YB); % Ybus magnitude matrix
t = angle(YB); % Ybus angle matrix (in radians)
iter=0;
pwracur = 0.00025;
DC = 10;
% Power accuracy
% Set the maximum power residual to a high value
while max(abs(DC)) > pwracur % Testing the criterion
    iter = iter +1
    % Static Power flow equations
    P=[V(2)*V(1)*Y(2,1)*cos(t(2,1)-d(2)+d(1))+V(2)^2*Y(2,2)*cos(t(2,2))];
    Q = -V(2)*V(1)*Y(2,1)*sin(t(2,1)-d(2)+d(1))-V(2)^2*Y(2,2)*sin(t(2,2));
    % Elements of Jacobian Matrix
    J(1,1)=V(2)*V(1)*Y(2,1)*sin(t(2,1)-d(2)+d(1));
    J(1,2)=V(1)*Y(2,1)*cos(t(2,1)-d(2)+d(1))+2*V(2)*Y(2,2)*cos(t(2,2));
    J(2,1)=V(2)*V(1)*Y(2,1)*cos(t(2,1)-d(2)+d(1));
    J(2,2)=-V(1)*Y(2,1)*sin(t(2,1)-d(2)+d(1))-2*V(2)*Y(2,2)*sin(t(2,2));
    DP = Ps - P;
    DQ = Qs - Q;
    DC = [DP; DQ]
    J
    DX = J\DC; % Evaluation of correction vector
    % Updation of State vectors
    d(2)=d(2)+DX(1);
    V(2)= V(2)+DX(2);
    V
    d
    delta =180/pi*d; %Bus angle in degrees
end
% Slack bus power
P1= V(1)^2*Y(1,1)*cos(t(1,1))+V(1)*V(2)*Y(1,2)*cos(t(1,2)-d(1)+d(2))
Q1=-V(1)^2*Y(1,1)*sin(t(1,1))-V(1)*V(2)*Y(1,2)*sin(t(1,2)-d(1)+d(2))

    clc 
clear 
V=[1.05; 1.0; 1.04]; %Voltage magnitude of buses (for PQ bus initialize) 
d=[0;0;0]; %Bus angles in radians 
Ps=[-4;2.0]; %Scheduled bus Real Power 
Qs=-2.5; %Scheduled bus Reactive Power 
% Bus admittance matrix of the system 
YB=[ 20-j*50 -10+j*20 -10+j*30; 
-10+j*20 26-j*52 -16+j*32; 
-10+j*30 -16+j*32 26-j*62]; 
Y= abs(YB); 
% Ybus magnitude matrix 
t = angle(YB); %Ybus angle matrix (in radians) 
iter=0; 
pwracur = 0.00025; 
% Power accuracy 
DC = 10; 
% Set the maximum power residual to a high value 
while max(abs(DC)) > pwracur 
    iter=iter+1 
    % Static Power flow equations 
    % Testing the criterion 
    P= [V(2)*V(1)*Y(2,1)*cos(t(2,1)-d(2)+d(1))+V(2)^2*Y(2,2)*cos(t(2,2))+ ... 
    V(2)*V(3)*Y(2,3)*cos(t(2,3)-d(2)+d(3)); 
    V(3)*V(1)*Y(3,1)*cos(t(3,1)-d(3)+d(1))+V(3)^2*Y(3,3)*cos(t(3,3))+... 
    V(3)*V(2)*Y(3,2)*cos(t(3,2)-d(3)+d(2))]; 
    Q = -V(2)*V(1)*Y(2,1)*sin(t(2,1)-d(2)+d(1))-V(2)^2*Y(2,2)*sin(t(2,2))- ... 
    V(2)*V(3)*Y(2,3)*sin(t(2,3)-d(2)+d(3)); 
    % Elements of Jacobian Matrix 
    J(1,1) = V(2)*V(1)*Y(2,1)*sin(t(2,1)-d(2)+d(1))+... 
    V(2)*V(3)*Y(2,3)*sin(t(2,3)-d(2)+d(3)); 
    J(1,2)=-V(2)*V(3)*Y(2,3)*sin(t(2,3)-d(2)+d(3)); 
    J(1,3)=V(1)*Y(2,1)*cos(t(2,1)-d(2)+d(1))+2*V(2)*Y(2,2)*cos(t(2,2))+... 
    V(3)*Y(2,3)*cos(t(2,3)-d(2)+d(3)); 
    J(2,1)=-V(3)*V(2)*Y(3,2)*sin(t(3,2)-d(3)+d(2)); 
    J(2,2)=V(3)*V(1)*Y(3,1)*sin(t(3,1)-d(3)+d(1))+... 
    V(3)*V(2)*Y(3,2)*sin(t(3,2)-d(3)+d(2)); 
    J(2,3)=V(3)*Y(2,3)*cos(t(3,2)-d(3)+d(2)); 
    J(3,1)=V(2)*V(1)*Y(2,1)*cos(t(2,1)-d(2)+d(1))+... 
    V(2)*V(3)*Y(2,3)*cos(t(2,3)-d(2)+d(3)); 
    J(3,2)=-V(2)*V(3)*Y(2,3)*cos(t(2,3)-d(2)+d(3)); 
    J(3,3)=-V(1)*Y(2,1)*sin(t(2,1)-d(2)+d(1))-2*V(2)*Y(2,2)*sin(t(2,2))-... 
    V(3)*Y(2,3)*sin(t(2,3)-d(2)+d(3)); 
    % Formation of del P and del Q 
    % vectos 
    DP = Ps - P; 
    DQ = Qs - Q; 
    DC = [DP; DQ]; 
    J 
    DX = J\DC; 
    % Evaluation of correction vector 
    % Updation of State vectors 
    d(2)=d(2)+DX(1); 
    d(3)=d(3)+DX(2); 
    V(2)=V(2)+DX(3); 
    V 
    d
    delta =180/pi*d; %Bus angle in degrees 
end
% Slack bus power 
P1=V(1)^2*Y(1,1)*cos(t(1,1))+V(1)*V(2)*Y(1,2)*cos(t(1,2)-d(1)+d(2))+... 
V(1)*V(3)*Y(1,3)*cos(t(1,3)-d(1)+d(3)) 
Q1=-V(1)^2*Y(1,1)*sin(t(1,1))-V(1)*V(2)*Y(1,2)*sin(t(1,2)-d(1)+d(2))-... 
V(1)*V(3)*Y(1,3)*sin(t(1,3)-d(1)+d(3)) 
% Reactive power of PV buses 
Q3=-V(3)*V(1)*Y(3,1)*sin(t(3,1)-d(3)+d(1))-V(3)*V(2)*Y(3,2)*... 
sin(t(3,2)-d(3)+d(2))-V(3)^2*Y(3,3)*sin(t(3,3)) 
</textarea>

<textarea id="exp5-code" class="hidden-code">
    clc 
clear 
V1=1.0; %slack bus voltage magnitude (given) 
V2=1.0; % PQ bus voltage magnitude intialization 
d1=0; %Slack bus voltage angle in radians (given) 
d2=0; %PQ bus voltage angle intialization in radians 
Ps=-1.0; % Scheduled bus Real Power 
Qs=-0.5; % Scheduled bus Reactive Power 
% Bus admittance matrix of the system 
YB=[3-j*4,-3+j*4;-3+j*4 3-j*4]; 
Y= abs(YB); % Ybus magnitude matrix 
t = angle(YB); % Ybus angle matrix (in radians) 
B=[-4]; 
Binv=inv(B); 
iter=0; 
pwracur = 0.00025; % Power accuracy 
DC = 10; 
% Set the maximum power residual to a high value 
while max(abs(DC)) > pwracur % Testing the criterion 
    iter=iter+1;
    % Static Power flow equations 
    P=V2*V1*Y(2,1)*cos(t(2,1)-d2+d1)+V2^2*Y(2,2)*cos(t(2,2)); 
    Q=-V2*V1*Y(2,1)*sin(t(2,1)-d2+d1)-V2^2*Y(2,2)*sin(t(2,2)); 
    % calculation of correction vectors 
    DP2=Ps-P; DP2V=DP2/V2; 
    DQ2=Qs-Q; DQ2V=DQ2/V2; 
    DC=[DP2;DQ2]; 
    Dd=-Binv*DP2V; 
    DV=-Binv*DQ2V; 
    d2=d2+Dd; 
    V2=V2+DV; 
    angle2 =180/pi*d2; 
    R=[iter d2 V2 DP2 DQ2]; 
    disp(R) 
end
% Slack bus power 
P1=V1^2*Y(1,1)*cos(t(1,1))+V1*V2*Y(1,2)*cos(t(1,2)-d1+d2); 
Q1=-V1^2*Y(1,1)*sin(t(1,1))-V1*V2*Y(1,2)*sin(t(1,2)-d1+d2); 
fprintf('Slack bus power in p.u\n'); 
S1=P1+j*Q1 
clc 
clear 
V1=1.05; %slack bus voltage magnitude (given) 
V2=1.0; % PQ bus voltage magnitude intialization 
V3=1.04; % PV bus voltage magnitude (given) 
d1=0; 
d2=0; 
% Slack bus voltage angle in radians (given) 
% PQ bus voltage angle intialization in radians 
d3=0; %PV bus voltage angle intialization in radians 
% Scheduled real power of PQ and PV buses 
Ps2=-4; Ps3 = 2.0; 
% Scheduled reactive power of PQ bus 
Qs2=-2.5; 
% Feed bus admittance matrix 
YB=[20-j*50 -10+j*20 -10+j*30; 
-10+j*20 26-j*52 -16+j*32; 
-10+j*30 -16+j*32 26-j*62]; 
Y= abs(YB); %Ybus magnitude 
t = angle(YB); %Ybus angle 
% feed B' matrix 
B=[-52 32; 32 -62]; 
Binv=inv(B); 
iter=0; 
pwracur = 0.0003; 
DC = 10; 
% Power accuracy 
% Set the max of power mismatch to a high value 
while max(abs(DC)) > pwracur 
    iter = iter +1; 
    % static load flow equations 
    P2 = V2*V1*Y(2,1)*cos(t(2,1)-d2+d1)+V2^2*Y(2,2)*cos(t(2,2))+ ... 
    V2*V3*Y(2,3)*cos(t(2,3)-d2+d3); 
   P3 = V3*V1*Y(3,1)*cos(t(3,1)-d3+d1)+V3^2*Y(3,3)*cos(t(3,3))+... 
   V3*V2*Y(3,2)*cos(t(3,2)-d3+d2); 
    Q2 = -V2*V1*Y(2,1)*sin(t(2,1)-d2+d1)-V2^2*Y(2,2)*sin(t(2,2))-... 
   V2*V3*Y(2,3)*sin(t(2,3)-d2+d3); 
    % calculation of correction vectors 
    DP2=Ps2-P2; DP2V=DP2/V2; 
    DP3=Ps3-P3; DP3V=DP3/V3; 
    DQ2=Qs2-Q2; DQ2V=DQ2/V2; 
    DC=[DP2; DP3; DQ2]; 
    Dd=-Binv*[DP2V;DP3V]; 
    DV=-1/B(1,1)*DQ2V; 
    d2=d2+Dd(1); 
    d3=d3+Dd(2); 
    V2=V2+DV; 
    angle2 =180/pi*d2; 
    angle3 =180/pi*d3; 
    R= [iter d2 d3 V2 DP2 DP3 DQ2]; 
    disp(R) 
end
Q3=-V3*V1*Y(3,1)*sin(t(3,1)-d3+d1)-V3^2*Y(3,3)*sin(t(3,3)) - ... 
V3*V2*Y(3,2)*sin(t(3,2)-d3+d2); 
P1 = V1^2*Y(1,1)*cos(t(1,1))+V1*V2*Y(1,2)*cos(t(1,2)-d1+d2)+... 
V1*V3*Y(1,3)*cos(t(1,3)-d1+d3); 
Q1= -V1^2*Y(1,1)*sin(t(1,1))-V1*V2*Y(1,2)*sin(t(1,2)-d1+d2)-... 
V1*V3*Y(1,3)*sin(t(1,3)-d1+d3); 
fprintf('Slack bus power in p.u\n'); 
S1=P1+j*Q1 
fprintf('Reactive power of bus 3 in p.u\n'); 
Q3 
</textarea>

<textarea id="exp6-code" class="hidden-code">
clc; 
clear 
format short g; 
Pm=[2.333 0.875 1.75]; %power limits for prefault, during fault,postfault conditions:'); 
Del_delta=0; i=1; 
f=50; %frequency 
tc=0.4; % Fault clearing time 
H=2.5; %inertia constant 
delta=25.3808; %initial displacement angle 
Pi=1; 
% initial steady state power:'); 
M=H/(180*f); y=0.05^2/M; 
k1=Pm(2)/Pm(1); k2=Pm(3)/Pm(1); 
del_int=delta*pi/180; 
del_max=pi-asin(sin(del_int)/k2); 
del_cri=acos(((del_max-del_int)*sin(del_int)-k1*cos(del_int)+k2*cos(del_max))/(k2-k1)); 
cri_t=(2*M*(del_cri-del_int)/Pi)^(1/2); 
del_cri=(del_cri*180)/pi; 
disp('Time Delta Pmax 
Delta') 
Pmax 
for t=0:0.05:1.05 
    delta=delta*pi/180; 
    if t==0
    end
    Paminus=Pi-1; 
    Pe 
    Paplus=Pi-Pm(2)*sin(delta); 
    Paavg=(Paminus+Paplus)/2; Pma=(Pm(1)+Pm(2))/2; sd=sin(delta); 
    Pa=Paavg; delta=(delta*180)/pi; 
    fprintf('%g-',t); 
    disp([Pm(1) sd Pi Paminus (y*Paminus) Del_delta delta]); 
    fprintf('%g+',t);
    disp([Pm(2) sd Pm(2)*sd Paplus (y*Paplus) Del_delta delta]); 
    fprintf('%gavg',t);
    disp([Pma sd Pma*sd Pa (y*Pa) Del_delta delta]) 
    if t < tc 
    end
    Paminus=Pi-Pm(2)*sin(delta); 
    Paplus=Pi-Pm(3)*sin(delta); 
    Paavg=(Paminus+Paplus)/2; Pma=(Pm(3)+Pm(2))/2; sd=sin(delta); 
    Pa=Paavg; delta=(delta*180)/pi; 
    fprintf('%g- ',tc); 
    disp([Pm(2) sd Pm(2)*sd Paminus (y*Paminus) Del_delta delta]); 
    fprintf('%g+',tc);
    disp([Pm(3) sd Pm(3)*sd Paplus (y*Paplus) Del_delta delta]); 
    fprintf('%gavg',tc);
    disp([Pma sd Pma*sd Pa (y*Pa) Del_delta delta]); 
    if t>0 && t<tc 
    end
    Pa=Pi-Pm(2)*sin(delta); sd=sin(delta); delta=(delta*180)/pi; 
    fprintf('%g',t)
    disp([Pm(2) sd Pm(2)*sd Pa (y*Pa) Del_delta delta]) 
    if (t>tc) 
    end
    Pa=Pi-Pm(3)*sin(delta); sd=sin(delta); delta=(delta*180)/pi; 
    fprintf('%g',t)
    disp([Pm(3) sd Pm(3)*sd Pa (y*Pa) Del_delta delta]) 
    Del_delta=Del_delta+(y*Pa); 
    time(i)=t; 
    del(i)=delta; 
    delta=delta+Del_delta; 
    i=i+1; 
end
critical_clearing_angle=del_cri 
critical_clearing_time=cri_t 
plot(time,del) 
title('SWING CURVE') 
xlabel('t, sec'); 
ylabel('delta,elec.deg') 
grid on
</textarea>
<textarea id="exp7-code" class="hidden-code">
    clc 
clear 
% for exercise 1 
Pm=0.8; E=1.17; V=1.0; X1=0.65; X2=inf; X3=0.65; 
% for exercise 2 
% Pm=0.8; E=1.17; V=1.0; X1=0.65; X2=1.8; X3=0.8; 
Pe1max=E*V/X1; Pe2max=E*V/X2; Pe3max=E*V/X3; 
delta=0:.01:pi; 
Pe1 = Pe1max*sin(delta); 
Pe2 = Pe2max*sin(delta); 
Pe3 = Pe3max*sin(delta); 
d0=asin(Pm/Pe1max); dmax=pi-asin(Pm/Pe3max); 
% general expression for critical clearing angle (both sending end and 
% middle of one line) 
cosdc=(Pm*(dmax-d0)+Pe3max*cos(dmax)-Pe2max*cos(d0))/(Pe3max-Pe2max); 
dc=acos(cosdc); % Critical clearing angle 
Pmx=[0 pi-d0]*180/pi; Pmy=[Pm Pm]; 
x0=[d0 d0]*180/pi; y0=[0 Pm]; 
xc=[dc dc]*180/pi; yc=[0 Pe3max*sin(dc)]; 
xm=[dmax dmax]*180/pi; ym=[0 Pe3max*sin(dmax)]; 
d0=d0*180/pi; dmax=dmax*180/pi; dc=dc*180/pi; 
x=(d0:.1:dc); 
y=Pe2max*sin(x*pi/180); 
y1=Pe2max*sin(d0*pi/180); 
y2=Pe2max*sin(dc*pi/180); 
x=[d0 x dc]; 
y=[Pm y Pm]; 
xx=dc:.1:dmax; 
hh=Pe3max*sin(xx*pi/180); 
xx=[dc xx dmax]; 
hh=[Pm hh Pm]; 
delta=delta*180/pi; 
if X2 == inf 
    fprintf('\nFor this case tc can be found from analytical formula. \n') 
    H=5; % given in the problem 
    if H~=0 
        d0r=d0*pi/180; dcr=dc*pi/180; 
        tc=sqrt(2*H*(dcr-d0r)/(pi*60*Pm)); 
    else, end 
else, end 
clc 
fprintf('\nInitial power angle = %7.3f \n', d0) 
fprintf('Maximum angle swing = %7.3f \n', dmax) 
fprintf('Critical clearing angle = %7.3f \n\n', dc) 
if X2 == inf & H~=0 
    fprintf('Critical clearing time = %7.3f sec. \n\n', tc) 
else, end 
h=figure; figure(h); 
fill(x,y,'m') 
hold; 
fill(xx,hh,'c') 
plot(delta,Pe1,'-',delta,Pe2,'r',delta,Pe3,'g-',Pmx,Pmy,'b',x0,y0,xc,yc,xm,ym 
), grid 
title('Application of equal area criterion to a critically cleared system') 
xlabel('Power angle, degree'), ylabel(' Power, per unit') 
text(5,1.07*Pm,'Pm') 
text(50,1.05*Pe1max,['Critical clearing angle = ' num2str(dc)]) 
axis([0 180 0 1.1*Pe1max]) 
hold off 
    
    clc 
clear 
% for exercise 1 
% Pm=0.8; E=1.17; V=1.0; X1=0.65; X2=inf; X3=0.65; 
% for exercise 2 
Pm=0.8; E=1.17; V=1.0; X1=0.65; X2=1.8; X3=0.8; 
Pe1max=E*V/X1; Pe2max=E*V/X2; Pe3max=E*V/X3; 
delta=0:.01:pi; 
Pe1 = Pe1max*sin(delta); 
Pe2 = Pe2max*sin(delta); 
Pe3 = Pe3max*sin(delta); 
d0=asin(Pm/Pe1max); 
dmax = pi-asin(Pm/Pe3max); 
% general expression for critical clearing angle (both sending end and 
% middle of one line) 
cosdc=(Pm*(dmax-d0)+Pe3max*cos(dmax)-Pe2max*cos(d0))/(Pe3max-Pe2max); 
dc=acos(cosdc); % Critical clearing angle 
Pmx=[0 pi-d0]*180/pi; Pmy=[Pm Pm]; 
x0=[d0 d0]*180/pi; y0=[0 Pm]; 
xc=[dc dc]*180/pi; yc=[0 Pe3max*sin(dc)]; 
xm=[dmax dmax]*180/pi; ym=[0 Pe3max*sin(dmax)]; 
d0=d0*180/pi; dmax=dmax*180/pi; dc=dc*180/pi; 
x=(d0:.1:dc); 
y=Pe2max*sin(x*pi/180); 
y1=Pe2max*sin(d0*pi/180); 
y2=Pe2max*sin(dc*pi/180); 
x=[d0 x dc]; 
y=[Pm y Pm]; 
xx=dc:.1:dmax; 
hh=Pe3max*sin(xx*pi/180); 
xx=[dc xx dmax]; 
hh=[Pm hh Pm]; 
delta=delta*180/pi; 
if X2 == inf 
    fprintf('\nFor this case tc can be found from analytical formula. \n') 
    H=input('To find tc enter Inertia Constant H, (or 0 to skip) H = '); 
    if H~=0 
        d0r=d0*pi/180; dcr=dc*pi/180; 
        tc = sqrt(2*H*(dcr-d0r)/(pi*60*Pm)); 
    else, end 
else, end 
clc 
fprintf('\nInitial power angle = %7.3f \n', d0) 
fprintf('Maximum angle swing = %7.3f \n', dmax) 
fprintf('Critical clearing angle = %7.3f \n\n', dc) 
if X2 == inf & H~=0 
    fprintf('Critical clearing time = %7.3f sec. \n\n', tc) 
else, end 
h=figure; figure(h); 
fill(x,y,'m') 
hold; 
fill(xx,hh,'c') 
plot(delta,Pe1,'-',delta,Pe2,'r',delta,Pe3,'g-',Pmx,Pmy,'b',x0,y0,xc,yc,xm,ym 
), grid 
title('Application of equal area criterion to a critically cleared system') 
xlabel('Power angle, degree'), ylabel(' Power, per unit') 
text(5,1.07*Pm,'Pm') 
text(50,1.05*Pe1max,['Critical clearing angle = ' num2str(dc)]) 
axis([0 180 0 1.1*Pe1max]) 
hold off 
</textarea>
<textarea id="exp14-code" class="hidden-code">
    %Script to run the kamlan filter model
%% System Parameters
SOC_vec = [0, .1, .25, .5, .75, .9, 1]; % Vector of state-of-charge values, SOC
T_vec   = [278, 293, 313];              % Vector of temperatures, T, (K)
AH      = 27;                           % Cell capacity, AH, (A*hr) 
thermal_mass = 100;                     % Thermal mass (J/K)
initialSOC = 0.5;                       % Battery initial SOC
V0_mat  = [3.49, 3.5, 3.51; 3.55, 3.57, 3.56; 3.62, 3.63, 3.64;...
    3.71, 3.71, 3.72; 3.91, 3.93, 3.94; 4.07, 4.08, 4.08;...
    4.19, 4.19, 4.19];                          % Open-circuit voltage, V0(SOC,T), (V)
R0_mat  = [.0117, .0085, .009; .011, .0085, .009;...
    .0114, .0087, .0092; .0107, .0082, .0088; .0107, .0083, .0091;...
    .0113, .0085, .0089; .0116, .0085, .0089];  % Terminal resistance, R0(SOC,T), (ohm)

R1_mat  = [.0109, .0029, .0013; .0069, .0024, .0012;...
    .0047, .0026, .0013; .0034, .0016, .001; .0033, .0023, .0014;...
    .0033, .0018, .0011; .0028, .0017, .0011];  % First polarization resistance, R1(SOC,T), (ohm)
tau1_mat = [20, 36, 39; 31, 45, 39; 109, 105, 61;...
    36, 29, 26; 59, 77, 67; 40, 33, 29; 25, 39, 33]; % First time constant, tau1(SOC,T), (s)

cell_area = 0.1019; % Cell area (m^2)
h_conv    = 5;      % Heat transfer coefficient (W/(K*m^2))

%% Kalman Filter
Q    = [1e-4 0; 0 1e-4]; % Covariance of the process noise, Q
R    = 0.7;              % Covariance of the measurement noise, R
P0   = [1e-5 0; 0 1];    % Initial state error covariance, P0
SOC0 = 0.8;              % Initial SOC for estimator 
Ts   = 1;                % Sample time
%%open the model
open_system('Exp14_Kalman_final')
sim("Exp14_Kalman_final")
</textarea>
    <script src="script.js"></script>
    <footer class="footer">
        For <span class="highlight">"Yejeevi Students ❤️"</span>
    </footer>

</body>
</html>
